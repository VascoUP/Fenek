
#include "V8Helper.h"

#include <iostream>
#include <vector>
#include <chrono>
#include <regex>

#include "GL\glew.h"
#include "GLFW\glfw3.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#include "Application.h"
#include "Shader.h"
#include "ComputeShader.h"
#include "V8Shader.h"
#include "V8ComputeShader.h"
#include "V8File.h"

using std::vector;
using std::cout;
using std::endl;
using std::regex;
using std::smatch;
using std::regex_match;
using std::ssub_match;

V8Helper *V8Helper::_instance = new V8Helper();

static long long start_time = std::chrono::high_resolution_clock::now().time_since_epoch().count();

typedef v8::Persistent<Function, v8::CopyablePersistentTraits<v8::Function>> PersistentFunction;

Local<v8::Script> V8Helper::compileScript(string command) {

	auto source = String::NewFromUtf8(isolate, command.c_str(), NewStringType::kNormal).ToLocalChecked();
	auto script = Script::Compile(context, source);
	//if (script.IsEmpty()) {
	//	return;
	//}

	auto lscript = script.ToLocalChecked();
	//auto result = lscript->Run(context);

	return lscript;
}

void V8Helper::runScriptSilent(string command) {

	auto source = String::NewFromUtf8(isolate, command.c_str(), NewStringType::kNormal).ToLocalChecked();
	auto script = Script::Compile(context, source);
	if (script.IsEmpty()) {
		return;
	}

	auto lscript = script.ToLocalChecked();
	auto result = lscript->Run(context);

}

int getErrorLine(string traceStr) {

	std::istringstream ss(traceStr.c_str());

	regex pattern(".*at .*:(\\d*):.\\d*");
	smatch result;

	string line;
	while (getline(ss, line, '\n')) {
		if (regex_match(line, result, pattern)) {
			ssub_match match_line = result[1];
			int line = std::stoi(match_line);

			return line - 1;
		} else {

		}
	}

	return -1;
}

string getNumberedLines(string str, int first, int last) {

	std::istringstream ss(str.c_str());

	string result = "";

	int i = 0;
	string line;
	while (getline(ss, line, '\n')) {

		if (i >= first && i <= last) {
			result = result + std::to_string(i + 1) + ":" + line + "\n";
		}

		i++;
	}

	return result;
}


// TODO copy&paste from v8 code example samples/shell.cc
// Extracts a C string from a V8 Utf8Value.
const char* ToCString(const v8::String::Utf8Value& value) {
	return *value ? *value : "<string conversion failed>";
}

// TODO copy&paste from v8 code example samples/shell.cc
void ReportException(v8::Isolate* isolate, v8::TryCatch* try_catch) {
	v8::HandleScope handle_scope(isolate);
	v8::String::Utf8Value exception(isolate, try_catch->Exception());
	const char* exception_string = ToCString(exception);
	v8::Local<v8::Message> message = try_catch->Message();
	if (message.IsEmpty()) {
		// V8 didn't provide any extra information about this error; just
		// print the exception.
		fprintf(stderr, "%s\n", exception_string);
	} else {
		// Print (filename):(line number): (message).
		v8::String::Utf8Value filename(isolate,
			message->GetScriptOrigin().ResourceName());
		v8::Local<v8::Context> context(isolate->GetCurrentContext());
		const char* filename_string = ToCString(filename);
		int linenum = message->GetLineNumber(context).FromJust();
		fprintf(stderr, "%s:%i: %s\n", filename_string, linenum, exception_string);
		// Print line of source code.
		v8::String::Utf8Value sourceline(
			isolate, message->GetSourceLine(context).ToLocalChecked());
		const char* sourceline_string = ToCString(sourceline);
		fprintf(stderr, "%s\n", sourceline_string);
		// Print wavy underline (GetUnderline is deprecated).
		int start = message->GetStartColumn(context).FromJust();
		for (int i = 0; i < start; i++) {
			fprintf(stderr, " ");
		}
		int end = message->GetEndColumn(context).FromJust();
		for (int i = start; i < end; i++) {
			fprintf(stderr, "^");
		}
		fprintf(stderr, "\n");
		v8::Local<v8::Value> stack_trace_string;
		if (try_catch->StackTrace(context).ToLocal(&stack_trace_string) &&
			stack_trace_string->IsString() &&
			v8::Local<v8::String>::Cast(stack_trace_string)->Length() > 0) {
			v8::String::Utf8Value stack_trace(isolate, stack_trace_string);
			const char* stack_trace_string = ToCString(stack_trace);
			fprintf(stderr, "%s\n", stack_trace_string);
		}
	}
}

bool V8Helper::runScript(string command) {

	//cout << ">> " << command << endl;
	bool report_exceptions = true;
	bool print_result = true;

	

	

	v8::Context::Scope context_scope(context);

	auto source = String::NewFromUtf8(isolate, command.c_str(),
		NewStringType::kNormal).ToLocalChecked();

	v8::Local<v8::String> name(
		v8::String::NewFromUtf8(context->GetIsolate(), "(blabla)",
			v8::NewStringType::kNormal).ToLocalChecked());

	v8::HandleScope handle_scope(isolate);
	v8::TryCatch try_catch(isolate);
	v8::ScriptOrigin origin(name);
	v8::Local<v8::Context> context(isolate->GetCurrentContext());
	v8::Local<v8::Script> script;

	auto result = v8::Script::Compile(context, source, &origin);
	if (!result.ToLocal(&script)) {
		// Print errors that happened during compilation.
		if (report_exceptions)
			ReportException(isolate, &try_catch);
		return false;
	} else {
		v8::Local<v8::Value> result;
		if (!script->Run(context).ToLocal(&result)) {
			assert(try_catch.HasCaught());
			// Print errors that happened during execution.
			if (report_exceptions)
				ReportException(isolate, &try_catch);
			return false;
		} else {
			assert(!try_catch.HasCaught());
			if (print_result && !result->IsUndefined()) {
				// If all went well and the result wasn't undefined then print
				// the returned value.
				v8::String::Utf8Value str(isolate, result);
				const char* cstr = ToCString(str);
				printf("%s\n", cstr);
			}
			return true;
		}
	}

	//auto lscript = script.ToLocalChecked();

	//TryCatch trycatch(isolate);

	//auto result = lscript->Run(context);
	//if (result.IsEmpty()) {
	//	cout << "failed to run script" << endl;
	//	//cout << command << endl;

	//	//Local<Value> exception = trycatch.Exception();
	//	//String::Utf8Value exception_str(exception);
	//	String::Utf8Value exception_str(isolate, trycatch.Exception());

	//	//Local<Value> trace = trycatch.StackTrace(isolate->GetCurrentContext()).ToLocalChecked();
	//	//String::Utf8Value trace_str(trace);
	//	//v8::String::Utf8Value trace_str(isolate, stack_trace_string);
	//	auto stack_trace_string = trycatch.StackTrace(context).ToLocalChecked();
	//	v8::String::Utf8Value trace_str(isolate, stack_trace_string);
	//	
	//	string exceptionStr = *exception_str;
	//	string traceStr = *trace_str;
	//	
	//	cout << "====" << endl;
	//	//cout << exceptionStr << endl;
	//	//cout << "====" << endl;
	//	
	//	cout << traceStr << endl;
	//	cout << "====" << endl;

	//	int line = getErrorLine(traceStr);

	//	if (line >= 0) {
	//		string lines = getNumberedLines(command, line - 2, line + 2);
	//		cout << lines;
	//	} else {
	//		cout << ":(" << endl;
	//	}

	//	cout << "====" << endl;
	//	//cout << traceStr << endl;
	//	//cout << "====" << endl;


	//	return;
	//}

	//auto lresult = result.ToLocalChecked();


	////String::Utf8Value utf8(isolate->GetCurrentContext(), lresult);
	//String::Utf8Value utf8(isolate, lresult);

	//if (*utf8 != nullptr) {
	//	cout << string(*utf8) << endl;
	//}
}

unordered_map<string, int> constants;

string ObjectToString(v8::Isolate* isolate, Local<Value> value) {
	String::Utf8Value utf8_value(isolate, value);
	return string(*utf8_value);
}


void V8Helper::setupGL() {

	// Create a template for the global object and set the
	// built-in global functions.
	Local<ObjectTemplate> tpl = ObjectTemplate::New(this->isolate);
	tpl->SetInternalFieldCount(1);
	Local<Object> obj = tpl->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();

	
//#define CREATE_CONSTANT_ACCESSOR( name, value) \
//	obj->SetAccessor(String::NewFromUtf8(isolate, name, NewStringType::kInternalized).ToLocalChecked(), [](Local<String> property, const PropertyCallbackInfo<Value>& info) { \
//		info.GetReturnValue().Set(value); \
//	})

#define CREATE_CONSTANT_ACCESSOR( name, value) \
	obj->Set(String::NewFromUtf8(isolate, name), v8::Integer::New(isolate, value));



	// ----------------------------
	//
	// this list was taken from and transformed into this form from the glew library,
	// GLEW under MIT: https://github.com/nigels-com/glew#copyright-and-licensing
	//
	// Notepad++:
	// find what:           #define GL_(\w*) (.*)
	// replace with:        CREATE_CONSTANT_ACCESSOR\("\1", \2\);
	//
	// ----------------------------
	
	
	setupV8GLExtBindings(obj);
	//setupV8GLExtBindings(tpl, constants);

	CREATE_CONSTANT_ACCESSOR("VERSION_1_1", 1);
	CREATE_CONSTANT_ACCESSOR("ZERO", 0);
	CREATE_CONSTANT_ACCESSOR("FALSE", 0);
	CREATE_CONSTANT_ACCESSOR("LOGIC_OP", 0x0BF1);
	CREATE_CONSTANT_ACCESSOR("NONE", 0);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COMPONENTS", 0x1003);
	CREATE_CONSTANT_ACCESSOR("NO_ERROR", 0);
	CREATE_CONSTANT_ACCESSOR("POINTS", 0x0000);
	CREATE_CONSTANT_ACCESSOR("CURRENT_BIT", 0x00000001);
	CREATE_CONSTANT_ACCESSOR("TRUE", 1);
	CREATE_CONSTANT_ACCESSOR("ONE", 1);
	CREATE_CONSTANT_ACCESSOR("CLIENT_PIXEL_STORE_BIT", 0x00000001);
	CREATE_CONSTANT_ACCESSOR("LINES", 0x0001);
	CREATE_CONSTANT_ACCESSOR("LINE_LOOP", 0x0002);
	CREATE_CONSTANT_ACCESSOR("POINT_BIT", 0x00000002);
	CREATE_CONSTANT_ACCESSOR("CLIENT_VERTEX_ARRAY_BIT", 0x00000002);
	CREATE_CONSTANT_ACCESSOR("LINE_STRIP", 0x0003);
	CREATE_CONSTANT_ACCESSOR("LINE_BIT", 0x00000004);
	CREATE_CONSTANT_ACCESSOR("TRIANGLES", 0x0004);
	CREATE_CONSTANT_ACCESSOR("TRIANGLE_STRIP", 0x0005);
	CREATE_CONSTANT_ACCESSOR("TRIANGLE_FAN", 0x0006);
	CREATE_CONSTANT_ACCESSOR("QUADS", 0x0007);
	CREATE_CONSTANT_ACCESSOR("QUAD_STRIP", 0x0008);
	CREATE_CONSTANT_ACCESSOR("POLYGON_BIT", 0x00000008);
	CREATE_CONSTANT_ACCESSOR("POLYGON", 0x0009);
	CREATE_CONSTANT_ACCESSOR("POLYGON_STIPPLE_BIT", 0x00000010);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MODE_BIT", 0x00000020);
	CREATE_CONSTANT_ACCESSOR("LIGHTING_BIT", 0x00000040);
	CREATE_CONSTANT_ACCESSOR("FOG_BIT", 0x00000080);
	CREATE_CONSTANT_ACCESSOR("DEPTH_BUFFER_BIT", 0x00000100);
	CREATE_CONSTANT_ACCESSOR("ACCUM", 0x0100);
	CREATE_CONSTANT_ACCESSOR("LOAD", 0x0101);
	CREATE_CONSTANT_ACCESSOR("RETURN", 0x0102);
	CREATE_CONSTANT_ACCESSOR("MULT", 0x0103);
	CREATE_CONSTANT_ACCESSOR("ADD", 0x0104);
	CREATE_CONSTANT_ACCESSOR("NEVER", 0x0200);
	CREATE_CONSTANT_ACCESSOR("ACCUM_BUFFER_BIT", 0x00000200);
	CREATE_CONSTANT_ACCESSOR("LESS", 0x0201);
	CREATE_CONSTANT_ACCESSOR("EQUAL", 0x0202);
	CREATE_CONSTANT_ACCESSOR("LEQUAL", 0x0203);
	CREATE_CONSTANT_ACCESSOR("GREATER", 0x0204);
	CREATE_CONSTANT_ACCESSOR("NOTEQUAL", 0x0205);
	CREATE_CONSTANT_ACCESSOR("GEQUAL", 0x0206);
	CREATE_CONSTANT_ACCESSOR("ALWAYS", 0x0207);
	CREATE_CONSTANT_ACCESSOR("SRC_COLOR", 0x0300);
	CREATE_CONSTANT_ACCESSOR("ONE_MINUS_SRC_COLOR", 0x0301);
	CREATE_CONSTANT_ACCESSOR("SRC_ALPHA", 0x0302);
	CREATE_CONSTANT_ACCESSOR("ONE_MINUS_SRC_ALPHA", 0x0303);
	CREATE_CONSTANT_ACCESSOR("DST_ALPHA", 0x0304);
	CREATE_CONSTANT_ACCESSOR("ONE_MINUS_DST_ALPHA", 0x0305);
	CREATE_CONSTANT_ACCESSOR("DST_COLOR", 0x0306);
	CREATE_CONSTANT_ACCESSOR("ONE_MINUS_DST_COLOR", 0x0307);
	CREATE_CONSTANT_ACCESSOR("SRC_ALPHA_SATURATE", 0x0308);
	CREATE_CONSTANT_ACCESSOR("STENCIL_BUFFER_BIT", 0x00000400);
	CREATE_CONSTANT_ACCESSOR("FRONT_LEFT", 0x0400);
	CREATE_CONSTANT_ACCESSOR("FRONT_RIGHT", 0x0401);
	CREATE_CONSTANT_ACCESSOR("BACK_LEFT", 0x0402);
	CREATE_CONSTANT_ACCESSOR("BACK_RIGHT", 0x0403);
	CREATE_CONSTANT_ACCESSOR("FRONT", 0x0404);
	CREATE_CONSTANT_ACCESSOR("BACK", 0x0405);
	CREATE_CONSTANT_ACCESSOR("LEFT", 0x0406);
	CREATE_CONSTANT_ACCESSOR("RIGHT", 0x0407);
	CREATE_CONSTANT_ACCESSOR("FRONT_AND_BACK", 0x0408);
	CREATE_CONSTANT_ACCESSOR("AUX0", 0x0409);
	CREATE_CONSTANT_ACCESSOR("AUX1", 0x040A);
	CREATE_CONSTANT_ACCESSOR("AUX2", 0x040B);
	CREATE_CONSTANT_ACCESSOR("AUX3", 0x040C);
	CREATE_CONSTANT_ACCESSOR("INVALID_ENUM", 0x0500);
	CREATE_CONSTANT_ACCESSOR("INVALID_VALUE", 0x0501);
	CREATE_CONSTANT_ACCESSOR("INVALID_OPERATION", 0x0502);
	CREATE_CONSTANT_ACCESSOR("STACK_OVERFLOW", 0x0503);
	CREATE_CONSTANT_ACCESSOR("STACK_UNDERFLOW", 0x0504);
	CREATE_CONSTANT_ACCESSOR("OUT_OF_MEMORY", 0x0505);
	CREATE_CONSTANT_ACCESSOR("2D", 0x0600);
	CREATE_CONSTANT_ACCESSOR("3D", 0x0601);
	CREATE_CONSTANT_ACCESSOR("3D_COLOR", 0x0602);
	CREATE_CONSTANT_ACCESSOR("3D_COLOR_TEXTURE", 0x0603);
	CREATE_CONSTANT_ACCESSOR("4D_COLOR_TEXTURE", 0x0604);
	CREATE_CONSTANT_ACCESSOR("PASS_THROUGH_TOKEN", 0x0700);
	CREATE_CONSTANT_ACCESSOR("POINT_TOKEN", 0x0701);
	CREATE_CONSTANT_ACCESSOR("LINE_TOKEN", 0x0702);
	CREATE_CONSTANT_ACCESSOR("POLYGON_TOKEN", 0x0703);
	CREATE_CONSTANT_ACCESSOR("BITMAP_TOKEN", 0x0704);
	CREATE_CONSTANT_ACCESSOR("DRAW_PIXEL_TOKEN", 0x0705);
	CREATE_CONSTANT_ACCESSOR("COPY_PIXEL_TOKEN", 0x0706);
	CREATE_CONSTANT_ACCESSOR("LINE_RESET_TOKEN", 0x0707);
	CREATE_CONSTANT_ACCESSOR("EXP", 0x0800);
	CREATE_CONSTANT_ACCESSOR("VIEWPORT_BIT", 0x00000800);
	CREATE_CONSTANT_ACCESSOR("EXP2", 0x0801);
	CREATE_CONSTANT_ACCESSOR("CW", 0x0900);
	CREATE_CONSTANT_ACCESSOR("CCW", 0x0901);
	CREATE_CONSTANT_ACCESSOR("COEFF", 0x0A00);
	CREATE_CONSTANT_ACCESSOR("ORDER", 0x0A01);
	CREATE_CONSTANT_ACCESSOR("DOMAIN", 0x0A02);
	CREATE_CONSTANT_ACCESSOR("CURRENT_COLOR", 0x0B00);
	CREATE_CONSTANT_ACCESSOR("CURRENT_INDEX", 0x0B01);
	CREATE_CONSTANT_ACCESSOR("CURRENT_NORMAL", 0x0B02);
	CREATE_CONSTANT_ACCESSOR("CURRENT_TEXTURE_COORDS", 0x0B03);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_COLOR", 0x0B04);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_INDEX", 0x0B05);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_TEXTURE_COORDS", 0x0B06);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_POSITION", 0x0B07);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_POSITION_VALID", 0x0B08);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_DISTANCE", 0x0B09);
	CREATE_CONSTANT_ACCESSOR("POINT_SMOOTH", 0x0B10);
	CREATE_CONSTANT_ACCESSOR("POINT_SIZE", 0x0B11);
	CREATE_CONSTANT_ACCESSOR("POINT_SIZE_RANGE", 0x0B12);
	CREATE_CONSTANT_ACCESSOR("POINT_SIZE_GRANULARITY", 0x0B13);
	CREATE_CONSTANT_ACCESSOR("LINE_SMOOTH", 0x0B20);
	CREATE_CONSTANT_ACCESSOR("LINE_WIDTH", 0x0B21);
	CREATE_CONSTANT_ACCESSOR("LINE_WIDTH_RANGE", 0x0B22);
	CREATE_CONSTANT_ACCESSOR("LINE_WIDTH_GRANULARITY", 0x0B23);
	CREATE_CONSTANT_ACCESSOR("LINE_STIPPLE", 0x0B24);
	CREATE_CONSTANT_ACCESSOR("LINE_STIPPLE_PATTERN", 0x0B25);
	CREATE_CONSTANT_ACCESSOR("LINE_STIPPLE_REPEAT", 0x0B26);
	CREATE_CONSTANT_ACCESSOR("LIST_MODE", 0x0B30);
	CREATE_CONSTANT_ACCESSOR("MAX_LIST_NESTING", 0x0B31);
	CREATE_CONSTANT_ACCESSOR("LIST_BASE", 0x0B32);
	CREATE_CONSTANT_ACCESSOR("LIST_INDEX", 0x0B33);
	CREATE_CONSTANT_ACCESSOR("POLYGON_MODE", 0x0B40);
	CREATE_CONSTANT_ACCESSOR("POLYGON_SMOOTH", 0x0B41);
	CREATE_CONSTANT_ACCESSOR("POLYGON_STIPPLE", 0x0B42);
	CREATE_CONSTANT_ACCESSOR("EDGE_FLAG", 0x0B43);
	CREATE_CONSTANT_ACCESSOR("CULL_FACE", 0x0B44);
	CREATE_CONSTANT_ACCESSOR("CULL_FACE_MODE", 0x0B45);
	CREATE_CONSTANT_ACCESSOR("FRONT_FACE", 0x0B46);
	CREATE_CONSTANT_ACCESSOR("LIGHTING", 0x0B50);
	CREATE_CONSTANT_ACCESSOR("LIGHT_MODEL_LOCAL_VIEWER", 0x0B51);
	CREATE_CONSTANT_ACCESSOR("LIGHT_MODEL_TWO_SIDE", 0x0B52);
	CREATE_CONSTANT_ACCESSOR("LIGHT_MODEL_AMBIENT", 0x0B53);
	CREATE_CONSTANT_ACCESSOR("SHADE_MODEL", 0x0B54);
	CREATE_CONSTANT_ACCESSOR("COLOR_MATERIAL_FACE", 0x0B55);
	CREATE_CONSTANT_ACCESSOR("COLOR_MATERIAL_PARAMETER", 0x0B56);
	CREATE_CONSTANT_ACCESSOR("COLOR_MATERIAL", 0x0B57);
	CREATE_CONSTANT_ACCESSOR("FOG", 0x0B60);
	CREATE_CONSTANT_ACCESSOR("FOG_INDEX", 0x0B61);
	CREATE_CONSTANT_ACCESSOR("FOG_DENSITY", 0x0B62);
	CREATE_CONSTANT_ACCESSOR("FOG_START", 0x0B63);
	CREATE_CONSTANT_ACCESSOR("FOG_END", 0x0B64);
	CREATE_CONSTANT_ACCESSOR("FOG_MODE", 0x0B65);
	CREATE_CONSTANT_ACCESSOR("FOG_COLOR", 0x0B66);
	CREATE_CONSTANT_ACCESSOR("DEPTH_RANGE", 0x0B70);
	CREATE_CONSTANT_ACCESSOR("DEPTH_TEST", 0x0B71);
	CREATE_CONSTANT_ACCESSOR("DEPTH_WRITEMASK", 0x0B72);
	CREATE_CONSTANT_ACCESSOR("DEPTH_CLEAR_VALUE", 0x0B73);
	CREATE_CONSTANT_ACCESSOR("DEPTH_FUNC", 0x0B74);
	CREATE_CONSTANT_ACCESSOR("ACCUM_CLEAR_VALUE", 0x0B80);
	CREATE_CONSTANT_ACCESSOR("STENCIL_TEST", 0x0B90);
	CREATE_CONSTANT_ACCESSOR("STENCIL_CLEAR_VALUE", 0x0B91);
	CREATE_CONSTANT_ACCESSOR("STENCIL_FUNC", 0x0B92);
	CREATE_CONSTANT_ACCESSOR("STENCIL_VALUE_MASK", 0x0B93);
	CREATE_CONSTANT_ACCESSOR("STENCIL_FAIL", 0x0B94);
	CREATE_CONSTANT_ACCESSOR("STENCIL_PASS_DEPTH_FAIL", 0x0B95);
	CREATE_CONSTANT_ACCESSOR("STENCIL_PASS_DEPTH_PASS", 0x0B96);
	CREATE_CONSTANT_ACCESSOR("STENCIL_REF", 0x0B97);
	CREATE_CONSTANT_ACCESSOR("STENCIL_WRITEMASK", 0x0B98);
	CREATE_CONSTANT_ACCESSOR("MATRIX_MODE", 0x0BA0);
	CREATE_CONSTANT_ACCESSOR("NORMALIZE", 0x0BA1);
	CREATE_CONSTANT_ACCESSOR("VIEWPORT", 0x0BA2);
	CREATE_CONSTANT_ACCESSOR("MODELVIEW_STACK_DEPTH", 0x0BA3);
	CREATE_CONSTANT_ACCESSOR("PROJECTION_STACK_DEPTH", 0x0BA4);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_STACK_DEPTH", 0x0BA5);
	CREATE_CONSTANT_ACCESSOR("MODELVIEW_MATRIX", 0x0BA6);
	CREATE_CONSTANT_ACCESSOR("PROJECTION_MATRIX", 0x0BA7);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_MATRIX", 0x0BA8);
	CREATE_CONSTANT_ACCESSOR("ATTRIB_STACK_DEPTH", 0x0BB0);
	CREATE_CONSTANT_ACCESSOR("CLIENT_ATTRIB_STACK_DEPTH", 0x0BB1);
	CREATE_CONSTANT_ACCESSOR("ALPHA_TEST", 0x0BC0);
	CREATE_CONSTANT_ACCESSOR("ALPHA_TEST_FUNC", 0x0BC1);
	CREATE_CONSTANT_ACCESSOR("ALPHA_TEST_REF", 0x0BC2);
	CREATE_CONSTANT_ACCESSOR("DITHER", 0x0BD0);
	CREATE_CONSTANT_ACCESSOR("BLEND_DST", 0x0BE0);
	CREATE_CONSTANT_ACCESSOR("BLEND_SRC", 0x0BE1);
	CREATE_CONSTANT_ACCESSOR("BLEND", 0x0BE2);
	CREATE_CONSTANT_ACCESSOR("LOGIC_OP_MODE", 0x0BF0);
	CREATE_CONSTANT_ACCESSOR("INDEX_LOGIC_OP", 0x0BF1);
	CREATE_CONSTANT_ACCESSOR("COLOR_LOGIC_OP", 0x0BF2);
	CREATE_CONSTANT_ACCESSOR("AUX_BUFFERS", 0x0C00);
	CREATE_CONSTANT_ACCESSOR("DRAW_BUFFER", 0x0C01);
	CREATE_CONSTANT_ACCESSOR("READ_BUFFER", 0x0C02);
	CREATE_CONSTANT_ACCESSOR("SCISSOR_BOX", 0x0C10);
	CREATE_CONSTANT_ACCESSOR("SCISSOR_TEST", 0x0C11);
	CREATE_CONSTANT_ACCESSOR("INDEX_CLEAR_VALUE", 0x0C20);
	CREATE_CONSTANT_ACCESSOR("INDEX_WRITEMASK", 0x0C21);
	CREATE_CONSTANT_ACCESSOR("COLOR_CLEAR_VALUE", 0x0C22);
	CREATE_CONSTANT_ACCESSOR("COLOR_WRITEMASK", 0x0C23);
	CREATE_CONSTANT_ACCESSOR("INDEX_MODE", 0x0C30);
	CREATE_CONSTANT_ACCESSOR("RGBA_MODE", 0x0C31);
	CREATE_CONSTANT_ACCESSOR("DOUBLEBUFFER", 0x0C32);
	CREATE_CONSTANT_ACCESSOR("STEREO", 0x0C33);
	CREATE_CONSTANT_ACCESSOR("RENDER_MODE", 0x0C40);
	CREATE_CONSTANT_ACCESSOR("PERSPECTIVE_CORRECTION_HINT", 0x0C50);
	CREATE_CONSTANT_ACCESSOR("POINT_SMOOTH_HINT", 0x0C51);
	CREATE_CONSTANT_ACCESSOR("LINE_SMOOTH_HINT", 0x0C52);
	CREATE_CONSTANT_ACCESSOR("POLYGON_SMOOTH_HINT", 0x0C53);
	CREATE_CONSTANT_ACCESSOR("FOG_HINT", 0x0C54);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GEN_S", 0x0C60);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GEN_T", 0x0C61);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GEN_R", 0x0C62);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GEN_Q", 0x0C63);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_I", 0x0C70);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_S_TO_S", 0x0C71);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_R", 0x0C72);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_G", 0x0C73);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_B", 0x0C74);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_A", 0x0C75);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_R_TO_R", 0x0C76);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_G_TO_G", 0x0C77);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_B_TO_B", 0x0C78);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_A_TO_A", 0x0C79);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_I_SIZE", 0x0CB0);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_S_TO_S_SIZE", 0x0CB1);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_R_SIZE", 0x0CB2);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_G_SIZE", 0x0CB3);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_B_SIZE", 0x0CB4);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_A_SIZE", 0x0CB5);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_R_TO_R_SIZE", 0x0CB6);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_G_TO_G_SIZE", 0x0CB7);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_B_TO_B_SIZE", 0x0CB8);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_A_TO_A_SIZE", 0x0CB9);
	CREATE_CONSTANT_ACCESSOR("UNPACK_SWAP_BYTES", 0x0CF0);
	CREATE_CONSTANT_ACCESSOR("UNPACK_LSB_FIRST", 0x0CF1);
	CREATE_CONSTANT_ACCESSOR("UNPACK_ROW_LENGTH", 0x0CF2);
	CREATE_CONSTANT_ACCESSOR("UNPACK_SKIP_ROWS", 0x0CF3);
	CREATE_CONSTANT_ACCESSOR("UNPACK_SKIP_PIXELS", 0x0CF4);
	CREATE_CONSTANT_ACCESSOR("UNPACK_ALIGNMENT", 0x0CF5);
	CREATE_CONSTANT_ACCESSOR("PACK_SWAP_BYTES", 0x0D00);
	CREATE_CONSTANT_ACCESSOR("PACK_LSB_FIRST", 0x0D01);
	CREATE_CONSTANT_ACCESSOR("PACK_ROW_LENGTH", 0x0D02);
	CREATE_CONSTANT_ACCESSOR("PACK_SKIP_ROWS", 0x0D03);
	CREATE_CONSTANT_ACCESSOR("PACK_SKIP_PIXELS", 0x0D04);
	CREATE_CONSTANT_ACCESSOR("PACK_ALIGNMENT", 0x0D05);
	CREATE_CONSTANT_ACCESSOR("MAP_COLOR", 0x0D10);
	CREATE_CONSTANT_ACCESSOR("MAP_STENCIL", 0x0D11);
	CREATE_CONSTANT_ACCESSOR("INDEX_SHIFT", 0x0D12);
	CREATE_CONSTANT_ACCESSOR("INDEX_OFFSET", 0x0D13);
	CREATE_CONSTANT_ACCESSOR("RED_SCALE", 0x0D14);
	CREATE_CONSTANT_ACCESSOR("RED_BIAS", 0x0D15);
	CREATE_CONSTANT_ACCESSOR("ZOOM_X", 0x0D16);
	CREATE_CONSTANT_ACCESSOR("ZOOM_Y", 0x0D17);
	CREATE_CONSTANT_ACCESSOR("GREEN_SCALE", 0x0D18);
	CREATE_CONSTANT_ACCESSOR("GREEN_BIAS", 0x0D19);
	CREATE_CONSTANT_ACCESSOR("BLUE_SCALE", 0x0D1A);
	CREATE_CONSTANT_ACCESSOR("BLUE_BIAS", 0x0D1B);
	CREATE_CONSTANT_ACCESSOR("ALPHA_SCALE", 0x0D1C);
	CREATE_CONSTANT_ACCESSOR("ALPHA_BIAS", 0x0D1D);
	CREATE_CONSTANT_ACCESSOR("DEPTH_SCALE", 0x0D1E);
	CREATE_CONSTANT_ACCESSOR("DEPTH_BIAS", 0x0D1F);
	CREATE_CONSTANT_ACCESSOR("MAX_EVAL_ORDER", 0x0D30);
	CREATE_CONSTANT_ACCESSOR("MAX_LIGHTS", 0x0D31);
	CREATE_CONSTANT_ACCESSOR("MAX_CLIP_PLANES", 0x0D32);
	CREATE_CONSTANT_ACCESSOR("MAX_TEXTURE_SIZE", 0x0D33);
	CREATE_CONSTANT_ACCESSOR("MAX_PIXEL_MAP_TABLE", 0x0D34);
	CREATE_CONSTANT_ACCESSOR("MAX_ATTRIB_STACK_DEPTH", 0x0D35);
	CREATE_CONSTANT_ACCESSOR("MAX_MODELVIEW_STACK_DEPTH", 0x0D36);
	CREATE_CONSTANT_ACCESSOR("MAX_NAME_STACK_DEPTH", 0x0D37);
	CREATE_CONSTANT_ACCESSOR("MAX_PROJECTION_STACK_DEPTH", 0x0D38);
	CREATE_CONSTANT_ACCESSOR("MAX_TEXTURE_STACK_DEPTH", 0x0D39);
	CREATE_CONSTANT_ACCESSOR("MAX_VIEWPORT_DIMS", 0x0D3A);
	CREATE_CONSTANT_ACCESSOR("MAX_CLIENT_ATTRIB_STACK_DEPTH", 0x0D3B);
	CREATE_CONSTANT_ACCESSOR("SUBPIXEL_BITS", 0x0D50);
	CREATE_CONSTANT_ACCESSOR("INDEX_BITS", 0x0D51);
	CREATE_CONSTANT_ACCESSOR("RED_BITS", 0x0D52);
	CREATE_CONSTANT_ACCESSOR("GREEN_BITS", 0x0D53);
	CREATE_CONSTANT_ACCESSOR("BLUE_BITS", 0x0D54);
	CREATE_CONSTANT_ACCESSOR("ALPHA_BITS", 0x0D55);
	CREATE_CONSTANT_ACCESSOR("DEPTH_BITS", 0x0D56);
	CREATE_CONSTANT_ACCESSOR("STENCIL_BITS", 0x0D57);
	CREATE_CONSTANT_ACCESSOR("ACCUM_RED_BITS", 0x0D58);
	CREATE_CONSTANT_ACCESSOR("ACCUM_GREEN_BITS", 0x0D59);
	CREATE_CONSTANT_ACCESSOR("ACCUM_BLUE_BITS", 0x0D5A);
	CREATE_CONSTANT_ACCESSOR("ACCUM_ALPHA_BITS", 0x0D5B);
	CREATE_CONSTANT_ACCESSOR("NAME_STACK_DEPTH", 0x0D70);
	CREATE_CONSTANT_ACCESSOR("AUTO_NORMAL", 0x0D80);
	CREATE_CONSTANT_ACCESSOR("MAP1_COLOR_4", 0x0D90);
	CREATE_CONSTANT_ACCESSOR("MAP1_INDEX", 0x0D91);
	CREATE_CONSTANT_ACCESSOR("MAP1_NORMAL", 0x0D92);
	CREATE_CONSTANT_ACCESSOR("MAP1_TEXTURE_COORD_1", 0x0D93);
	CREATE_CONSTANT_ACCESSOR("MAP1_TEXTURE_COORD_2", 0x0D94);
	CREATE_CONSTANT_ACCESSOR("MAP1_TEXTURE_COORD_3", 0x0D95);
	CREATE_CONSTANT_ACCESSOR("MAP1_TEXTURE_COORD_4", 0x0D96);
	CREATE_CONSTANT_ACCESSOR("MAP1_VERTEX_3", 0x0D97);
	CREATE_CONSTANT_ACCESSOR("MAP1_VERTEX_4", 0x0D98);
	CREATE_CONSTANT_ACCESSOR("MAP2_COLOR_4", 0x0DB0);
	CREATE_CONSTANT_ACCESSOR("MAP2_INDEX", 0x0DB1);
	CREATE_CONSTANT_ACCESSOR("MAP2_NORMAL", 0x0DB2);
	CREATE_CONSTANT_ACCESSOR("MAP2_TEXTURE_COORD_1", 0x0DB3);
	CREATE_CONSTANT_ACCESSOR("MAP2_TEXTURE_COORD_2", 0x0DB4);
	CREATE_CONSTANT_ACCESSOR("MAP2_TEXTURE_COORD_3", 0x0DB5);
	CREATE_CONSTANT_ACCESSOR("MAP2_TEXTURE_COORD_4", 0x0DB6);
	CREATE_CONSTANT_ACCESSOR("MAP2_VERTEX_3", 0x0DB7);
	CREATE_CONSTANT_ACCESSOR("MAP2_VERTEX_4", 0x0DB8);
	CREATE_CONSTANT_ACCESSOR("MAP1_GRID_DOMAIN", 0x0DD0);
	CREATE_CONSTANT_ACCESSOR("MAP1_GRID_SEGMENTS", 0x0DD1);
	CREATE_CONSTANT_ACCESSOR("MAP2_GRID_DOMAIN", 0x0DD2);
	CREATE_CONSTANT_ACCESSOR("MAP2_GRID_SEGMENTS", 0x0DD3);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_1D", 0x0DE0);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_2D", 0x0DE1);
	CREATE_CONSTANT_ACCESSOR("FEEDBACK_BUFFER_POINTER", 0x0DF0);
	CREATE_CONSTANT_ACCESSOR("FEEDBACK_BUFFER_SIZE", 0x0DF1);
	CREATE_CONSTANT_ACCESSOR("FEEDBACK_BUFFER_TYPE", 0x0DF2);
	CREATE_CONSTANT_ACCESSOR("SELECTION_BUFFER_POINTER", 0x0DF3);
	CREATE_CONSTANT_ACCESSOR("SELECTION_BUFFER_SIZE", 0x0DF4);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_WIDTH", 0x1000);
	CREATE_CONSTANT_ACCESSOR("TRANSFORM_BIT", 0x00001000);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_HEIGHT", 0x1001);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_INTERNAL_FORMAT", 0x1003);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BORDER_COLOR", 0x1004);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BORDER", 0x1005);
	CREATE_CONSTANT_ACCESSOR("DONT_CARE", 0x1100);
	CREATE_CONSTANT_ACCESSOR("FASTEST", 0x1101);
	CREATE_CONSTANT_ACCESSOR("NICEST", 0x1102);
	CREATE_CONSTANT_ACCESSOR("AMBIENT", 0x1200);
	CREATE_CONSTANT_ACCESSOR("DIFFUSE", 0x1201);
	CREATE_CONSTANT_ACCESSOR("SPECULAR", 0x1202);
	CREATE_CONSTANT_ACCESSOR("POSITION", 0x1203);
	CREATE_CONSTANT_ACCESSOR("SPOT_DIRECTION", 0x1204);
	CREATE_CONSTANT_ACCESSOR("SPOT_EXPONENT", 0x1205);
	CREATE_CONSTANT_ACCESSOR("SPOT_CUTOFF", 0x1206);
	CREATE_CONSTANT_ACCESSOR("CONSTANT_ATTENUATION", 0x1207);
	CREATE_CONSTANT_ACCESSOR("LINEAR_ATTENUATION", 0x1208);
	CREATE_CONSTANT_ACCESSOR("QUADRATIC_ATTENUATION", 0x1209);
	CREATE_CONSTANT_ACCESSOR("COMPILE", 0x1300);
	CREATE_CONSTANT_ACCESSOR("COMPILE_AND_EXECUTE", 0x1301);
	CREATE_CONSTANT_ACCESSOR("BYTE", 0x1400);
	CREATE_CONSTANT_ACCESSOR("UNSIGNED_BYTE", 0x1401);
	CREATE_CONSTANT_ACCESSOR("SHORT", 0x1402);
	CREATE_CONSTANT_ACCESSOR("UNSIGNED_SHORT", 0x1403);
	CREATE_CONSTANT_ACCESSOR("INT", 0x1404);
	CREATE_CONSTANT_ACCESSOR("UNSIGNED_INT", 0x1405);
	CREATE_CONSTANT_ACCESSOR("FLOAT", 0x1406);
	CREATE_CONSTANT_ACCESSOR("2_BYTES", 0x1407);
	CREATE_CONSTANT_ACCESSOR("3_BYTES", 0x1408);
	CREATE_CONSTANT_ACCESSOR("4_BYTES", 0x1409);
	CREATE_CONSTANT_ACCESSOR("DOUBLE", 0x140A);
	CREATE_CONSTANT_ACCESSOR("CLEAR", 0x1500);
	CREATE_CONSTANT_ACCESSOR("AND", 0x1501);
	CREATE_CONSTANT_ACCESSOR("AND_REVERSE", 0x1502);
	CREATE_CONSTANT_ACCESSOR("COPY", 0x1503);
	CREATE_CONSTANT_ACCESSOR("AND_INVERTED", 0x1504);
	CREATE_CONSTANT_ACCESSOR("NOOP", 0x1505);
	CREATE_CONSTANT_ACCESSOR("XOR", 0x1506);
	CREATE_CONSTANT_ACCESSOR("OR", 0x1507);
	CREATE_CONSTANT_ACCESSOR("NOR", 0x1508);
	CREATE_CONSTANT_ACCESSOR("EQUIV", 0x1509);
	CREATE_CONSTANT_ACCESSOR("INVERT", 0x150A);
	CREATE_CONSTANT_ACCESSOR("OR_REVERSE", 0x150B);
	CREATE_CONSTANT_ACCESSOR("COPY_INVERTED", 0x150C);
	CREATE_CONSTANT_ACCESSOR("OR_INVERTED", 0x150D);
	CREATE_CONSTANT_ACCESSOR("NAND", 0x150E);
	CREATE_CONSTANT_ACCESSOR("SET", 0x150F);
	CREATE_CONSTANT_ACCESSOR("EMISSION", 0x1600);
	CREATE_CONSTANT_ACCESSOR("SHININESS", 0x1601);
	CREATE_CONSTANT_ACCESSOR("AMBIENT_AND_DIFFUSE", 0x1602);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEXES", 0x1603);
	CREATE_CONSTANT_ACCESSOR("MODELVIEW", 0x1700);
	CREATE_CONSTANT_ACCESSOR("PROJECTION", 0x1701);
	CREATE_CONSTANT_ACCESSOR("TEXTURE", 0x1702);
	CREATE_CONSTANT_ACCESSOR("COLOR", 0x1800);
	CREATE_CONSTANT_ACCESSOR("DEPTH", 0x1801);
	CREATE_CONSTANT_ACCESSOR("STENCIL", 0x1802);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX", 0x1900);
	CREATE_CONSTANT_ACCESSOR("STENCIL_INDEX", 0x1901);
	CREATE_CONSTANT_ACCESSOR("DEPTH_COMPONENT", 0x1902);
	CREATE_CONSTANT_ACCESSOR("RED", 0x1903);
	CREATE_CONSTANT_ACCESSOR("GREEN", 0x1904);
	CREATE_CONSTANT_ACCESSOR("BLUE", 0x1905);
	CREATE_CONSTANT_ACCESSOR("ALPHA", 0x1906);
	CREATE_CONSTANT_ACCESSOR("RGB", 0x1907);
	CREATE_CONSTANT_ACCESSOR("RGBA", 0x1908);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE", 0x1909);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE_ALPHA", 0x190A);
	CREATE_CONSTANT_ACCESSOR("BITMAP", 0x1A00);
	CREATE_CONSTANT_ACCESSOR("POINT", 0x1B00);
	CREATE_CONSTANT_ACCESSOR("LINE", 0x1B01);
	CREATE_CONSTANT_ACCESSOR("FILL", 0x1B02);
	CREATE_CONSTANT_ACCESSOR("RENDER", 0x1C00);
	CREATE_CONSTANT_ACCESSOR("FEEDBACK", 0x1C01);
	CREATE_CONSTANT_ACCESSOR("SELECT", 0x1C02);
	CREATE_CONSTANT_ACCESSOR("FLAT", 0x1D00);
	CREATE_CONSTANT_ACCESSOR("SMOOTH", 0x1D01);
	CREATE_CONSTANT_ACCESSOR("KEEP", 0x1E00);
	CREATE_CONSTANT_ACCESSOR("REPLACE", 0x1E01);
	CREATE_CONSTANT_ACCESSOR("INCR", 0x1E02);
	CREATE_CONSTANT_ACCESSOR("DECR", 0x1E03);
	CREATE_CONSTANT_ACCESSOR("VENDOR", 0x1F00);
	CREATE_CONSTANT_ACCESSOR("RENDERER", 0x1F01);
	CREATE_CONSTANT_ACCESSOR("VERSION", 0x1F02);
	CREATE_CONSTANT_ACCESSOR("EXTENSIONS", 0x1F03);
	CREATE_CONSTANT_ACCESSOR("S", 0x2000);
	CREATE_CONSTANT_ACCESSOR("ENABLE_BIT", 0x00002000);
	CREATE_CONSTANT_ACCESSOR("T", 0x2001);
	CREATE_CONSTANT_ACCESSOR("R", 0x2002);
	CREATE_CONSTANT_ACCESSOR("Q", 0x2003);
	CREATE_CONSTANT_ACCESSOR("MODULATE", 0x2100);
	CREATE_CONSTANT_ACCESSOR("DECAL", 0x2101);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_ENV_MODE", 0x2200);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_ENV_COLOR", 0x2201);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_ENV", 0x2300);
	CREATE_CONSTANT_ACCESSOR("EYE_LINEAR", 0x2400);
	CREATE_CONSTANT_ACCESSOR("OBJECT_LINEAR", 0x2401);
	CREATE_CONSTANT_ACCESSOR("SPHERE_MAP", 0x2402);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GEN_MODE", 0x2500);
	CREATE_CONSTANT_ACCESSOR("OBJECT_PLANE", 0x2501);
	CREATE_CONSTANT_ACCESSOR("EYE_PLANE", 0x2502);
	CREATE_CONSTANT_ACCESSOR("NEAREST", 0x2600);
	CREATE_CONSTANT_ACCESSOR("LINEAR", 0x2601);
	CREATE_CONSTANT_ACCESSOR("NEAREST_MIPMAP_NEAREST", 0x2700);
	CREATE_CONSTANT_ACCESSOR("LINEAR_MIPMAP_NEAREST", 0x2701);
	CREATE_CONSTANT_ACCESSOR("NEAREST_MIPMAP_LINEAR", 0x2702);
	CREATE_CONSTANT_ACCESSOR("LINEAR_MIPMAP_LINEAR", 0x2703);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_MAG_FILTER", 0x2800);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_MIN_FILTER", 0x2801);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_WRAP_S", 0x2802);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_WRAP_T", 0x2803);
	CREATE_CONSTANT_ACCESSOR("CLAMP", 0x2900);
	CREATE_CONSTANT_ACCESSOR("REPEAT", 0x2901);
	CREATE_CONSTANT_ACCESSOR("POLYGON_OFFSET_UNITS", 0x2A00);
	CREATE_CONSTANT_ACCESSOR("POLYGON_OFFSET_POINT", 0x2A01);
	CREATE_CONSTANT_ACCESSOR("POLYGON_OFFSET_LINE", 0x2A02);
	CREATE_CONSTANT_ACCESSOR("R3_G3_B2", 0x2A10);
	CREATE_CONSTANT_ACCESSOR("V2F", 0x2A20);
	CREATE_CONSTANT_ACCESSOR("V3F", 0x2A21);
	CREATE_CONSTANT_ACCESSOR("C4UB_V2F", 0x2A22);
	CREATE_CONSTANT_ACCESSOR("C4UB_V3F", 0x2A23);
	CREATE_CONSTANT_ACCESSOR("C3F_V3F", 0x2A24);
	CREATE_CONSTANT_ACCESSOR("N3F_V3F", 0x2A25);
	CREATE_CONSTANT_ACCESSOR("C4F_N3F_V3F", 0x2A26);
	CREATE_CONSTANT_ACCESSOR("T2F_V3F", 0x2A27);
	CREATE_CONSTANT_ACCESSOR("T4F_V4F", 0x2A28);
	CREATE_CONSTANT_ACCESSOR("T2F_C4UB_V3F", 0x2A29);
	CREATE_CONSTANT_ACCESSOR("T2F_C3F_V3F", 0x2A2A);
	CREATE_CONSTANT_ACCESSOR("T2F_N3F_V3F", 0x2A2B);
	CREATE_CONSTANT_ACCESSOR("T2F_C4F_N3F_V3F", 0x2A2C);
	CREATE_CONSTANT_ACCESSOR("T4F_C4F_N3F_V4F", 0x2A2D);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE0", 0x3000);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE1", 0x3001);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE2", 0x3002);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE3", 0x3003);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE4", 0x3004);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE5", 0x3005);
	CREATE_CONSTANT_ACCESSOR("LIGHT0", 0x4000);
	CREATE_CONSTANT_ACCESSOR("COLOR_BUFFER_BIT", 0x00004000);
	CREATE_CONSTANT_ACCESSOR("LIGHT1", 0x4001);
	CREATE_CONSTANT_ACCESSOR("LIGHT2", 0x4002);
	CREATE_CONSTANT_ACCESSOR("LIGHT3", 0x4003);
	CREATE_CONSTANT_ACCESSOR("LIGHT4", 0x4004);
	CREATE_CONSTANT_ACCESSOR("LIGHT5", 0x4005);
	CREATE_CONSTANT_ACCESSOR("LIGHT6", 0x4006);
	CREATE_CONSTANT_ACCESSOR("LIGHT7", 0x4007);
	CREATE_CONSTANT_ACCESSOR("HINT_BIT", 0x00008000);
	CREATE_CONSTANT_ACCESSOR("POLYGON_OFFSET_FILL", 0x8037);
	CREATE_CONSTANT_ACCESSOR("POLYGON_OFFSET_FACTOR", 0x8038);
	CREATE_CONSTANT_ACCESSOR("ALPHA4", 0x803B);
	CREATE_CONSTANT_ACCESSOR("ALPHA8", 0x803C);
	CREATE_CONSTANT_ACCESSOR("ALPHA12", 0x803D);
	CREATE_CONSTANT_ACCESSOR("ALPHA16", 0x803E);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE4", 0x803F);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE8", 0x8040);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE12", 0x8041);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE16", 0x8042);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE4_ALPHA4", 0x8043);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE6_ALPHA2", 0x8044);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE8_ALPHA8", 0x8045);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE12_ALPHA4", 0x8046);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE12_ALPHA12", 0x8047);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE16_ALPHA16", 0x8048);
	CREATE_CONSTANT_ACCESSOR("INTENSITY", 0x8049);
	CREATE_CONSTANT_ACCESSOR("INTENSITY4", 0x804A);
	CREATE_CONSTANT_ACCESSOR("INTENSITY8", 0x804B);
	CREATE_CONSTANT_ACCESSOR("INTENSITY12", 0x804C);
	CREATE_CONSTANT_ACCESSOR("INTENSITY16", 0x804D);
	CREATE_CONSTANT_ACCESSOR("RGB4", 0x804F);
	CREATE_CONSTANT_ACCESSOR("RGB5", 0x8050);
	CREATE_CONSTANT_ACCESSOR("RGB8", 0x8051);
	CREATE_CONSTANT_ACCESSOR("RGB10", 0x8052);
	CREATE_CONSTANT_ACCESSOR("RGB12", 0x8053);
	CREATE_CONSTANT_ACCESSOR("RGB16", 0x8054);
	CREATE_CONSTANT_ACCESSOR("RGBA2", 0x8055);
	CREATE_CONSTANT_ACCESSOR("RGBA4", 0x8056);
	CREATE_CONSTANT_ACCESSOR("RGB5_A1", 0x8057);
	CREATE_CONSTANT_ACCESSOR("RGBA8", 0x8058);
	CREATE_CONSTANT_ACCESSOR("RGB10_A2", 0x8059);
	CREATE_CONSTANT_ACCESSOR("RGBA12", 0x805A);
	CREATE_CONSTANT_ACCESSOR("RGBA16", 0x805B);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_RED_SIZE", 0x805C);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GREEN_SIZE", 0x805D);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BLUE_SIZE", 0x805E);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_ALPHA_SIZE", 0x805F);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_LUMINANCE_SIZE", 0x8060);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_INTENSITY_SIZE", 0x8061);
	CREATE_CONSTANT_ACCESSOR("PROXY_TEXTURE_1D", 0x8063);
	CREATE_CONSTANT_ACCESSOR("PROXY_TEXTURE_2D", 0x8064);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_PRIORITY", 0x8066);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_RESIDENT", 0x8067);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BINDING_1D", 0x8068);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BINDING_2D", 0x8069);
	CREATE_CONSTANT_ACCESSOR("VERTEX_ARRAY", 0x8074);
	CREATE_CONSTANT_ACCESSOR("NORMAL_ARRAY", 0x8075);
	CREATE_CONSTANT_ACCESSOR("COLOR_ARRAY", 0x8076);
	CREATE_CONSTANT_ACCESSOR("INDEX_ARRAY", 0x8077);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COORD_ARRAY", 0x8078);
	CREATE_CONSTANT_ACCESSOR("EDGE_FLAG_ARRAY", 0x8079);
	CREATE_CONSTANT_ACCESSOR("VERTEX_ARRAY_SIZE", 0x807A);
	CREATE_CONSTANT_ACCESSOR("VERTEX_ARRAY_TYPE", 0x807B);
	CREATE_CONSTANT_ACCESSOR("VERTEX_ARRAY_STRIDE", 0x807C);
	CREATE_CONSTANT_ACCESSOR("NORMAL_ARRAY_TYPE", 0x807E);
	CREATE_CONSTANT_ACCESSOR("NORMAL_ARRAY_STRIDE", 0x807F);
	CREATE_CONSTANT_ACCESSOR("COLOR_ARRAY_SIZE", 0x8081);
	CREATE_CONSTANT_ACCESSOR("COLOR_ARRAY_TYPE", 0x8082);
	CREATE_CONSTANT_ACCESSOR("COLOR_ARRAY_STRIDE", 0x8083);
	CREATE_CONSTANT_ACCESSOR("INDEX_ARRAY_TYPE", 0x8085);
	CREATE_CONSTANT_ACCESSOR("INDEX_ARRAY_STRIDE", 0x8086);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COORD_ARRAY_SIZE", 0x8088);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COORD_ARRAY_TYPE", 0x8089);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COORD_ARRAY_STRIDE", 0x808A);
	CREATE_CONSTANT_ACCESSOR("EDGE_FLAG_ARRAY_STRIDE", 0x808C);
	CREATE_CONSTANT_ACCESSOR("VERTEX_ARRAY_POINTER", 0x808E);
	CREATE_CONSTANT_ACCESSOR("NORMAL_ARRAY_POINTER", 0x808F);
	CREATE_CONSTANT_ACCESSOR("COLOR_ARRAY_POINTER", 0x8090);
	CREATE_CONSTANT_ACCESSOR("INDEX_ARRAY_POINTER", 0x8091);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COORD_ARRAY_POINTER", 0x8092);
	CREATE_CONSTANT_ACCESSOR("EDGE_FLAG_ARRAY_POINTER", 0x8093);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX1_EXT", 0x80E2);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX2_EXT", 0x80E3);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX4_EXT", 0x80E4);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX8_EXT", 0x80E5);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX12_EXT", 0x80E6);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX16_EXT", 0x80E7);
	CREATE_CONSTANT_ACCESSOR("EVAL_BIT", 0x00010000);
	CREATE_CONSTANT_ACCESSOR("LIST_BIT", 0x00020000);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BIT", 0x00040000);
	CREATE_CONSTANT_ACCESSOR("SCISSOR_BIT", 0x00080000);
	CREATE_CONSTANT_ACCESSOR("ALL_ATTRIB_BITS", 0x000fffff);
	CREATE_CONSTANT_ACCESSOR("CLIENT_ALL_ATTRIB_BITS", 0xffffffff);




	obj->Set(String::NewFromUtf8(isolate, "clearColor"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 4) {
			V8Helper::_instance->throwException("clearColor requires 4 arguments");
			return;
		}

		float red = (float)args[0]->NumberValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		float green= (float)args[1]->NumberValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		float blue = (float)args[2]->NumberValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		float alpha = (float)args[3]->NumberValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		//cout << key << ": " << value << endl;
		glClearColor(red, green, blue, alpha);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "clearDepth"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("clearDepth requires 1 arguments");
			return;
		}

		double depth = args[0]->NumberValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		glClearDepth(depth);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "depthFunc"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("depthFunc requires 1 arguments");
			return;
		}

		GLenum depthFunc = args[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		glDepthFunc(depthFunc);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "clear"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("clear requires 1 argument");
			return;
		}

		GLbitfield mask = args[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		glClear(mask);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "createVertexArray"), Function::New(context, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 0) {
			V8Helper::_instance->throwException("createVertexArray requires 0 arguments");
			return;
		}

		GLuint vao = -1;
		glCreateVertexArrays(1, &vao);

		info.GetReturnValue().Set(vao);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "createTexture"), Function::New(context, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 0) {
			V8Helper::_instance->throwException("createTexture requires 0 arguments");
			return;
		}

		GLuint tex = -1;
		glGenTextures(1, &tex);

		info.GetReturnValue().Set(tex);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "deleteTexture"), Function::New(context, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 1) {
			V8Helper::_instance->throwException("deleteTexture requires 1 arguments");
			return;
		}

		GLuint tex = info[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		glDeleteTextures(1, &tex);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "texImage2D"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 9) {
			V8Helper::_instance->throwException("texImage2D requires 9 arguments");
			return;
		}

		GLenum target = args[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLint level = args[1]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLint internalFormat = args[2]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLsizei width = args[3]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLsizei height = args[4]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLint border = args[5]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLenum format = args[6]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLenum type = args[7]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		
		void* data = nullptr;
		if (args[8]->IsArrayBuffer()) {
			v8::Local<v8::ArrayBuffer> buffer = (args[8]).As<v8::ArrayBuffer>();
			void *bdata = buffer->GetContents().Data();
			data = reinterpret_cast<void*>(bdata);
		} else if (args[8]->IsArrayBufferView()) {
			v8::Local<v8::ArrayBufferView> view = (args[8]).As<v8::ArrayBufferView>();
			auto buffer = view->Buffer();
			void *bdata = view->Buffer()->GetContents().Data();
			data = reinterpret_cast<void*>(bdata);
		} else if (args[8]->IsNumber()) {
			int value = (int)args[8]->NumberValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
			data = (void*)value;
		} else {
			cout << "ERROR(texImage2D): array must be of type ArrayBuffer" << endl;
			exit(1);
		}

		glTexImage2D(target, level, internalFormat, width, height, border, format, type, data);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "texSubImage2D"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 9) {
			V8Helper::_instance->throwException("texSubImage2D requires 9 arguments");
			return;
		}

		GLenum target = args[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLint level = args[1]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLint xoffset = args[2]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLint yoffset = args[3]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLsizei width = args[4]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLsizei height = args[5]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLenum format = args[6]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLenum type = args[7]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		void* data = nullptr;
		if (args[8]->IsArrayBuffer()) {
			v8::Local<v8::ArrayBuffer> buffer = (args[8]).As<v8::ArrayBuffer>();
			void *bdata = buffer->GetContents().Data();
			data = reinterpret_cast<void*>(bdata);
		} else if (args[8]->IsArrayBufferView()) {
			v8::Local<v8::ArrayBufferView> view = (args[8]).As<v8::ArrayBufferView>();
			auto buffer = view->Buffer();
			void *bdata = view->Buffer()->GetContents().Data();
			data = reinterpret_cast<void*>(bdata);
		} else if (args[8]->IsNumber()) {
			int value = args[8]->NumberValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
			data = (void*)value;
		} else {
			cout << "ERROR(texImage2D): array must be of type ArrayBuffer" << endl;
			exit(1);
		}

		glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, data);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "createProgram"), Function::New(context, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 0) {
			V8Helper::_instance->throwException("createProgram requires 0 arguments");
			return;
		}

		GLuint program = glCreateProgram();

		info.GetReturnValue().Set(program);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "createShader"), Function::New(context, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 1) {
			V8Helper::_instance->throwException("createShader requires 1 arguments");
			return;
		}

		GLenum shaderType = info[0]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		GLuint shader = glCreateShader(shaderType);

		info.GetReturnValue().Set(shader);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "shaderSource"), Function::New(context, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 2) {
			V8Helper::_instance->throwException("shaderSource requires 2 arguments");
			return;
		}

		int shader = info[0]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		String::Utf8Value sourceUTF8(v8::Isolate::GetCurrent(), info[1]);
		string source = *sourceUTF8;

		const char* csource = source.c_str();

		// glShaderSource(glshader, 1, &vsc, NULL);
		glShaderSource(shader, 1, &csource, NULL);

		info.GetReturnValue().Set(shader);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "getUniformLocation"), Function::New(context, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 2) {
			V8Helper::_instance->throwException("getUniformLocation requires 2 arguments");
			return;
		}

		int program = info[0]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		String::Utf8Value nameUTF8(v8::Isolate::GetCurrent(), info[1]);
		string name = *nameUTF8;

		const char* cname = name.c_str();

		// glShaderSource(glshader, 1, &vsc, NULL);
		auto id = glGetUniformLocation(program, cname);

		info.GetReturnValue().Set(id);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "getUniformBlockIndex"), Function::New(context, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 2) {
			V8Helper::_instance->throwException("getUniformBlockIndex requires 2 arguments");
			return;
		}

		int program = info[0]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		String::Utf8Value nameUTF8(v8::Isolate::GetCurrent(), info[1]);
		string name = *nameUTF8;
		const char* cname = name.c_str();

		// glShaderSource(glshader, 1, &vsc, NULL);
		auto index = glGetUniformBlockIndex(program, cname);

		info.GetReturnValue().Set(index);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "getError"), Function::New(context, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 0) {
			V8Helper::_instance->throwException("getError requires 0 arguments");
			return;
		}

		int error = glGetError();

		info.GetReturnValue().Set(error);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "createBuffer"), Function::New(context, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 0) {
			V8Helper::_instance->throwException("createBuffer requires 0 arguments");
			return;
		}

		GLuint buffer = -1;
		glCreateBuffers(1, &buffer);

		info.GetReturnValue().Set(buffer);
	}).ToLocalChecked());

	//obj->Set(String::NewFromUtf8(isolate, "glBindBufferBase"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
	//	if (args.Length() != 3) {
	//		V8Helper::_instance->throwException("glBindBufferBase requires 3 argument");
	//		return;
	//	}

	//	String::Utf8Value targetUTF8(args[0]);
	//	String::Utf8Value indexUTF8(args[1]);
	//	String::Utf8Value bufferUTF8(args[2]);

	//	GLenum target = std::stoi(*targetUTF8);
	//	GLuint index = std::stoi(*indexUTF8);
	//	GLuint buffer = std::stoi(*bufferUTF8);

	//	glBindBufferBase(target, index, buffer);
	//}));

	obj->Set(String::NewFromUtf8(isolate, "createFramebuffer"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 0) {
			V8Helper::_instance->throwException("createFramebuffer requires 0 arguments");
			return;
		}

		GLuint fb;
		glGenFramebuffers(1, &fb);

		args.GetReturnValue().Set(fb);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "viewport"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 4) {
			V8Helper::_instance->throwException("viewport requires 4 argument");
			return;
		}

		GLint x = args[0]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLint y = args[1]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLsizei width = args[2]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLsizei height = args[3]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		glViewport(x, y, width, height);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "bindTexture"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("bindTexture requires 2 argument");
			return;
		}

		GLenum target = args[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLuint texture = args[1]->IntegerValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		glBindTexture(target, texture);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "texParameteri"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 3) {
			V8Helper::_instance->throwException("texParameteri requires 3 argument");
			return;
		}

		GLenum target = args[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLenum pname = args[1]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLint param = args[2]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		glTexParameteri(target, pname, param);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "blendFunc"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("blendFunc requires 2 arguments");
			return;
		}

		GLenum sfactor = args[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLenum dfactor = args[1]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		glBlendFunc(sfactor, dfactor);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "flush"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 0) {
			V8Helper::_instance->throwException("flush requires 0 arguments");
			return;
		}

		glFlush();
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "enable"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("enable requires 1 argument");
			return;
		}

		GLenum value = args[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		glEnable(value);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "disable"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("disable requires 1 argument");
			return;
		}

		GLenum value = args[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		glDisable(value);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "drawArrays"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 3) {
			V8Helper::_instance->throwException("drawArrays requires 3 arguments");
			return;
		}

		GLenum mode = args[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLint first = args[1]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLsizei count = args[2]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		glDrawArrays(mode, first, count);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "createQuery"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 0) {
			V8Helper::_instance->throwException("createQuery requires 0 arguments");
			return;
		}

		unsigned int queryID;
		glGenQueries(1, &queryID);

		args.GetReturnValue().Set(queryID);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "deleteQuery"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("deleteQuery requires 1 arguments");
			return;
		}

		unsigned int queryID = args[0]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		glDeleteQueries(1, &queryID);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "getQueryObjectui64"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("getQueryObjectui64 requires 2 arguments");
			return;
		}

		int query = args[0]->Int32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		GLenum pname = args[1]->Uint32Value(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		unsigned long long params;
		glGetQueryObjectui64v(query, pname, &params);

		double val = (double)params;

		args.GetReturnValue().Set(val);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "depthMask"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("depthMask requires 1 arguments");
			return;
		}

		bool mask = args[0]->BooleanValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(false);

		glDepthMask(mask);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "getInteger64v"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("depthMask requires 1 arguments");
			return;
		}

		GLenum target = args[0]->IntegerValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		GLint64 value;

		glGetInteger64v(target, &value);

		double v = value;

		args.GetReturnValue().Set(v);
	}).ToLocalChecked());

	obj->Set(String::NewFromUtf8(isolate, "exit"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("exit requires 0 arguments");
			return;
		}

		exit(0);
	}).ToLocalChecked());

	

	context->Global()->Set(
		String::NewFromUtf8(isolate, "gl"),
		obj
	);



	
}


void V8Helper::setupV8() {


	//auto testFunc = [](const FunctionCallbackInfo<Value>& args) {
	//	cout << "lala!!" << endl;
	//};

	//auto testFunc2 = [](const FunctionCallbackInfo<Value>& args) {
	//	cout << "omg!!" << endl;
	//};


	auto global = v8::ObjectTemplate::New(isolate);

	//registerFunction("test", [](const FunctionCallbackInfo<Value>& args) {
	//	cout << "woohoo!!" << endl;
	//});

	//return v8::Context::New(isolate, NULL, global);


	context = v8::Context::New(isolate, NULL, global);

	Context::Scope context_scope(context);

	this->global = context->Global();

	/*auto f2Name = v8::String::NewFromUtf8(isolate, "test2");
	auto f2 = v8::Function::New(context, testFunc2).ToLocalChecked();
	glob->Set(f2Name, f2);*/
	

	registerFunction("acquireDesktopTexture", [](const FunctionCallbackInfo<Value>& args) {
		auto app = Application::instance();
		DesktopTexture result = app->acquireDesktopTexture();

		auto isolate = Isolate::GetCurrent();
		Local<ObjectTemplate> imgTempl = ObjectTemplate::New(isolate);
		auto object = imgTempl->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();

		auto lTextureHandle = v8::Integer::New(isolate, result.textureHandle);
		auto lHasChanged = v8::Boolean::New(isolate, result.hasChanged);

		object->Set(String::NewFromUtf8(isolate, "handle"), lTextureHandle);
		object->Set(String::NewFromUtf8(isolate, "hasChanged"), lHasChanged);

		args.GetReturnValue().Set(object);
	});

	registerFunction("getCursorData", [](const FunctionCallbackInfo<Value>& args) {
		auto app = Application::instance();
		MouseCursor cursor = app->getCursor();

		Local<ArrayBuffer> v8Buffer = v8::ArrayBuffer::New(Isolate::GetCurrent(), cursor.data.size());

		auto v8Data = v8Buffer->GetContents().Data();

		// TODO: load file content directly to v8 buffer to 2x allocation and a copy
		memcpy(v8Data, cursor.data.data(), cursor.data.size());

		auto isolate = Isolate::GetCurrent();
		Local<ObjectTemplate> imgTempl = ObjectTemplate::New(isolate);

		auto lwidth = v8::Integer::New(isolate, cursor.width);
		auto lheight = v8::Integer::New(isolate, cursor.height);
		auto lx = v8::Integer::New(isolate, cursor.x);
		auto ly = v8::Integer::New(isolate, cursor.y);
		auto ltype = v8::Integer::New(isolate, cursor.type);
		auto lpitch = v8::Integer::New(isolate, cursor.pitch);

		auto object = imgTempl->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();

		object->Set(String::NewFromUtf8(isolate, "width"), lwidth);
		object->Set(String::NewFromUtf8(isolate, "height"), lheight);
		object->Set(String::NewFromUtf8(isolate, "x"), lx);
		object->Set(String::NewFromUtf8(isolate, "y"), ly);
		object->Set(String::NewFromUtf8(isolate, "type"), ltype);
		object->Set(String::NewFromUtf8(isolate, "pitch"), lpitch);
		object->Set(String::NewFromUtf8(isolate, "data"), v8Buffer);

		args.GetReturnValue().Set(object);
	});

	registerFunction("setDebugValue", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("setDebugValue requires 2 arguments");
			return;
		}

		auto isolate = v8::Isolate::GetCurrent();

		String::Utf8Value strKey(isolate, args[0]);
		String::Utf8Value strValue(isolate, args[1]);

		string key = *strKey;
		string value = *strValue;

		V8Helper::instance()->debugValue[key] = value;

		//cout << key << ": " << value << endl;
	});

	registerFunction("removeDebugValue", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("removeDebugValue requires 1 arguments");
			return;
		}

		auto isolate = v8::Isolate::GetCurrent();

		String::Utf8Value strKey(isolate, args[0]);

		string key = *strKey;

		V8Helper::instance()->debugValue.erase(key);

		//cout << key << ": " << value << endl;
	});

	registerFunction("reportState", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("reportState requires 1 arguments");
			return;
		}

		bool reportState = args[0]->BooleanValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(false);

		Application::instance()->reportState = reportState;
	});

	registerFunction("log", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("log requires 1 argument");
			return;
		}

		auto isolate = v8::Isolate::GetCurrent();

		String::Utf8Value messageUTF8(isolate, args[0]);

		string message = *messageUTF8;

		cout << message << endl;
	});

	registerFunction("readFile", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("readFile requires 1 arguments");
			return;
		}

		auto isolate = v8::Isolate::GetCurrent();

		String::Utf8Value fileUTF8(isolate, args[0]);

		string file = *fileUTF8;

		vector<char> buffer = loadFile(file);

		Local<ArrayBuffer> v8Buffer = v8::ArrayBuffer::New(Isolate::GetCurrent(), buffer.size());

		auto v8Data = v8Buffer->GetContents().Data();

		// TODO: load file content directly to v8 buffer to 2x allocation and a copy
		memcpy(v8Data, buffer.data(), buffer.size());

		args.GetReturnValue().Set(v8Buffer);
	});

	registerFunction("loadImage", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("loadImage requires 1 arguments");
			return;
		}

		auto isolate = Isolate::GetCurrent();

		String::Utf8Value fileUTF8(isolate, args[0]);
		string file = *fileUTF8;

		int width, height, channels;
		unsigned char *data = stbi_load(file.c_str(), &width, &height, &channels, 4);

		int size = width * height * 4;

		Local<ArrayBuffer> v8Buffer = v8::ArrayBuffer::New(Isolate::GetCurrent(), size);

		auto v8Data = v8Buffer->GetContents().Data();

		// TODO: load file content directly to v8 buffer to 2x allocation and a copy
		memcpy(v8Data, data, size);

		Local<ObjectTemplate> imgTempl = ObjectTemplate::New(isolate);

		auto lwidth = v8::Integer::New(isolate, width);
		auto lheight= v8::Integer::New(isolate, height);

		//imgTempl->Set(isolate, "width", lwidth);
		//imgTempl->Set(isolate, "height", lheight);
		//imgTempl->Set(isolate, "data", v8Buffer);

		auto object = imgTempl->NewInstance(isolate->GetCurrentContext()).ToLocalChecked();

		object->Set(String::NewFromUtf8(isolate, "width"), lwidth);
		object->Set(String::NewFromUtf8(isolate, "height"), lheight);
		object->Set(String::NewFromUtf8(isolate, "data"), v8Buffer);


		args.GetReturnValue().Set(object);
	});

	

	registerFunction("readTextFile", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("readFile requires 1 arguments");
			return;
		}

		auto isolate = v8::Isolate::GetCurrent();

		String::Utf8Value fileUTF8(isolate, args[0]);

		string file = *fileUTF8;

		// see https://stackoverflow.com/questions/2602013/read-whole-ascii-file-into-c-stdstring
		std::ifstream t(file);
		std::stringstream buffer;
		buffer << t.rdbuf();
		string text = buffer.str();

		auto v8str = v8::String::NewFromUtf8(Isolate::GetCurrent(), text.c_str());

		args.GetReturnValue().Set(v8str);
	});

	registerFunction("openFile", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("openFile requires 1 arguments");
			return;
		}

		auto isolate = v8::Isolate::GetCurrent();

		String::Utf8Value vsSourceUTF8(isolate, args[0]);

		string path = *vsSourceUTF8;

		File *file = new File(path);
		auto v8File = v8Object(file);

		//auto programID = shader->program;
		args.GetReturnValue().Set(v8File);
	});

	registerFunction("monitorFile", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("monitorFile requires 2 arguments");
			return;
		}

		v8::Isolate *isolate = Isolate::GetCurrent();

		String::Utf8Value fileUTF8(isolate, args[0]);
		string file = *fileUTF8;

		Local<Value> callbackValue = args[1];
		Local<Function> callback = Local<Function>::Cast(callbackValue);

		auto persistent = PersistentFunction(isolate, callback);

		monitorFile(file, [isolate, persistent]() {
			
			Local<Function> local = Local<Function>::New(isolate, persistent);

			int argc = 0;
			Local<Value> argv[1];
			
			local->Call(isolate->GetCurrentContext(), local, argc, argv);

		});

		//auto programID = shader->program;
		//args.GetReturnValue().Set(v8Shader);
	});

	registerFunction("watchShader", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("watchShader requires 2 arguments");
			return;
		}

		auto isolate = v8::Isolate::GetCurrent();

		String::Utf8Value vsSourceUTF8(isolate, args[0]);
		String::Utf8Value fsSourceUTF8(isolate, args[1]);

		string vsSource = *vsSourceUTF8;
		string fsSource = *fsSourceUTF8;

		Shader *shader = new Shader(vsSource, fsSource);
		auto v8Shader = v8Object(shader);

		monitorFile(vsSource, [shader]() {
			shader->compile();
		});

		monitorFile(fsSource, [shader]() {
			shader->compile();
		});

		//auto programID = shader->program;
		args.GetReturnValue().Set(v8Shader);
	});

	registerFunction("watchComputeShader", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("watchComputeShader requires 1 argument");
			return;
		}

		auto isolate = v8::Isolate::GetCurrent();

		String::Utf8Value csSourceUTF8(isolate, args[0]);

		string csSource = *csSourceUTF8;

		ComputeShader *shader = new ComputeShader(csSource);
		auto v8Shader = v8Object(shader);

		monitorFile(csSource, [shader]() {
			shader->compile();
		});

		args.GetReturnValue().Set(v8Shader);
	});

	registerFunction("watchJS", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("watchJS requires 1 argument");
			return;
		}

		auto isolate = v8::Isolate::GetCurrent();

		String::Utf8Value jsSourceUTF8(isolate, args[0]);

		string jsSource = *jsSourceUTF8;

		string code = loadFileAsString(jsSource);
		V8Helper::instance()->runScriptSilent(code);

		monitorFile(jsSource, [jsSource]() {
			string code = loadFileAsString(jsSource);
			V8Helper::instance()->runScriptSilent(code);
		});
	});

	registerFunction("runJSFile", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("runJSFile requires 1 argument");
			return;
		}

		auto isolate = v8::Isolate::GetCurrent();

		String::Utf8Value jsSourceUTF8(isolate, args[0]);

		string jsSource = *jsSourceUTF8;

		string code = loadFileAsString(jsSource);

		V8Helper::instance()->runScript(code);
	});

	registerFunction("now", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 0) {
			V8Helper::_instance->throwException("now requires 0 arguments");
			return;
		}

		auto now = std::chrono::high_resolution_clock::now();
		long long nanosSinceStart = now.time_since_epoch().count() - start_time;

		double secondsSinceStart = double(nanosSinceStart) / 1'000'000'000;

		args.GetReturnValue().Set(secondsSinceStart);
	});

	typedef Persistent<Promise::Resolver, CopyablePersistentTraits<Promise::Resolver>> PersistentResolver;
	static unordered_map<long long, PersistentResolver> resolvers;
	static long long resolverID = 0;

	registerFunction("readFileAsync", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("readFileAsync requires 1 arguments");
			return;
		}
		auto isolate = Isolate::GetCurrent();

		String::Utf8Value fileUTF8(isolate, args[0]);

		string file = *fileUTF8;

		Local<Promise::Resolver> resolver = v8::Promise::Resolver::New(isolate->GetCurrentContext()).ToLocalChecked();

		long long currentID = resolverID++;
		resolvers[currentID] = PersistentResolver(isolate, resolver);

		thread t([file, isolate, currentID](){

			vector<char> buffer = loadFile(file);

			schedule([currentID, isolate, buffer/*, startThread*/]() {
				Local<ArrayBuffer> v8Buffer = v8::ArrayBuffer::New(Isolate::GetCurrent(), buffer.size());
		
				auto v8Data = v8Buffer->GetContents().Data();
		
				// TODO: load file content directly to v8 buffer to avoid 2x allocation and a copy
				memcpy(v8Data, buffer.data(), buffer.size());

				auto persistantResolver = resolvers[currentID];
				Local<Promise::Resolver> resolver = Local<Promise::Resolver>::New(isolate, persistantResolver);

				resolver->Resolve(isolate->GetCurrentContext(), v8Buffer);

				resolvers.erase(currentID);
			});
			
		}); 
		t.detach();

		args.GetReturnValue().Set(resolver->GetPromise());

	});


	struct IPoint {
		int ux;
		int uy;
		int uz;
		unsigned char r;
		unsigned char g;
		unsigned char b;
		unsigned char a;
	};

	struct OPoint {
		float x;
		float y;
		float z;
		unsigned char r;
		unsigned char g;
		unsigned char b;
		unsigned char a;
	};

	registerFunction("loadNodeAsync", [](const FunctionCallbackInfo<Value>& args) {
	//V8Helper::_instance->context->Global()->Set(String::NewFromUtf8(isolate, "loadNodeAsync"), Function::New(context, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 5) {
			V8Helper::_instance->throwException("loadNodeAsync requires 5 arguments");
			return;
		}

		auto isolate = Isolate::GetCurrent();

		String::Utf8Value fileUTF8(isolate, args[0]);

		string file = *fileUTF8;
		float scale = (float)args[1]->NumberValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		float minX = (float)args[2]->NumberValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		float minY = (float)args[3]->NumberValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);
		float minZ = (float)args[4]->NumberValue(v8::Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(-1);

		Local<Promise::Resolver> resolver = v8::Promise::Resolver::New(isolate->GetCurrentContext()).ToLocalChecked();

		long long currentID = resolverID++;
		resolvers[currentID] = PersistentResolver(isolate, resolver);

		thread t([file, scale, minX, minY, minZ, isolate, currentID]() {

			vector<char> buffer = loadFile(file);
			int numPoints = buffer.size() / 16;

			IPoint *source = reinterpret_cast<IPoint*>(buffer.data());
			vector<OPoint> target = vector<OPoint>();
			target.reserve(numPoints);

			for (int i = 0; i < numPoints; i++) {
				IPoint s = source[i];
				OPoint t;

				t.x = s.ux * scale + minX;
				t.y = s.uy * scale + minY;
				t.z = s.uz * scale + minZ;

				t.r = s.r;
				t.g = s.g;
				t.b = s.b;
				t.a = 255;

				target.push_back(t);
			}








			schedule([currentID, isolate, target/*, startThread*/]() {
				Local<ArrayBuffer> v8Buffer = v8::ArrayBuffer::New(Isolate::GetCurrent(), target.size() * sizeof(OPoint));

				auto v8Data = v8Buffer->GetContents().Data();

				// TODO: load file content directly to v8 buffer to avoid 2x allocation and a copy
				memcpy(v8Data, target.data(), target.size() * sizeof(OPoint));

				auto persistantResolver = resolvers[currentID];
				Local<Promise::Resolver> resolver = Local<Promise::Resolver>::New(isolate, persistantResolver);

				resolver->Resolve(isolate->GetCurrentContext(), v8Buffer);

				resolvers.erase(currentID);
			});

		});
		t.detach();

		args.GetReturnValue().Set(resolver->GetPromise());
	});


	setupWindow();
	setupGL();
	setupVR();

}